### Задание 1: EventEmitter

[Код](https://github.com/mrpq/shri_algos_2/blob/master/eventEmitter.js)

Для хранения используется структура данных вида

```
{
    'eventName': [список коллбэков]
}
```

При этом для списка колбэков используется объект Set, появившийся в ES6, а сами списки колбэков хранятся в ассоциативном массиве (Map, так же появился в ES6). Выбор основан на том, что под капотом у в них используются хэш таблицы (речь о V8), дающие в среднем константное время вставки / чтения / записи, и линейное в худшем случае. Таким образом в среднем подписка / отписка моем эмитере выполняются за `O(1)`. Вызов emit() работает за `O(n)`, где `n` - количество подписчиков на данное событие. Расход памяти - `O(n)`, где `n` - общее количество подписок для всех событий.

---

### Задание 2: Саджест

Реализовал требуемый функционал тремя алгоритмами:

* на базе встроенной функции `String.indexOf()`
* на базе наивного алгоритма поиска
* на базе поиска подстроки по алгоритму boyer moore horspool

Алгоритмы перечислены в порядке убывания по производительности.

сразу обозначим следующие переменные
`m` - число улиц в массиве
`H` - средняя длина названия улицы
`n` - длина шаблона поиска
`E` - размер алфавита (в нашем случае алфавит русского языка + все цифры + символ пробела)

1.  Так, лучше всего в данной конкретной задаче себя показал поиск с использованием встроенного метода `String.indexOf()`. При этом сложно оценить time complexity и потребление, т.к. я не знаю какой алгоритм используется для реализации данной функции. К тому же наверняка реализация и сопутствующие внутренние оптимизации могут отличаться от движка к движку. Пусть функция скорости роста для `String.indexOf` будет `g(H)`
    тогда time complexity для обсуждаемого алгоритма будет `O(m * g(H))`

2.  Наивный алгоритм каждый раз сдвигает шаблон относительно текста на один символ, и заново посимвольно проверяет есть ли совпадения. В среднем отрабатывает за `2H`, в худшем случае (когда очень длинная строка например `aaa.....ab`, а шаблон длинная строка `aaaa...ac`) время будет `O(H * (H - n))`
    Таким образом для моего алгоритма в худщем случае time complexity будет `O(m * H * (H - n))`
    Расход памяти, если не принимать в расчет список улиц, который уже находится в памяти - `n`

3.  Алгоритм Бойера-Мура-Хорспула - тратит незначительное время на подготовку для искомого шаблона за `O(n + E)`, что позволяет ему сдвигать шаблон относительно начала текста в зависимости от ситуации более чем на один символ, далее отрабатывает в среднем за время `2H / E`, в худшем за `O(H * n)`
    Таким образом для моего алгоритма в худщем случае time complexity будет `O(m * H * n)`  
    Расход памяти, если не принимать в расчет список улиц, который уже находится в памяти - `H + n + E`

Все перечисленные подходы решают поставленную задачу вывода suggest'ов для всех улиц Москвы за более чем приемлемое время (учитывая, что время между нажатиями на клавиши не привышает 150мс, а все алгоритмы отрабатывают за несколько мс). Таким образом стоит сделать выбор в пользу наиболее читаемого варианта. Таковым является c indexOf

Для серьезных объемов (миллионы строк например, либо много достаточно длинных строк), и условие, что у нас достаточно памяти, я бы использовал суффиксные деревья. Надеюсь до проверки успею запилить быстрое построение деревьев по алгоритму Укконена для миллиона строк + _почти_ мгновенный поиск.
