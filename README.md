Реализовал требуемый функционал тремя алгоритмами:

* на базе встроенной функции `String.indexOf()`
* на базе наивного алгоритма поиска
* на базе поиска подстроки по алгоритму boyer moore horspool

Алгоритмы перечислены в порядке убывания по производительности.

сразу обозначим следующие переменные
m - число улиц в массиве
H - средняя длина названия улицы
n - длина шаблона поиска
E - размер алфавита (алфавит русского языка + все цифры + символ пробела)

1.  Так, лучше всего в данной конкретной задаче себя показал поиск с использованием встроенного метода `String.indexOf()`. При этом сложно оценить time complexity и потребление, т.к. я не знаю какой алгоритм используется для реализации данной функции. К тому же наверняка реализация и сопутствующие внутренние оптимизации могут отличаться от движка к движку. Пусть функция скорости роста для `String.indexOf` будет `g(H)`
    тогда time complexity для обсуждаемого алгоритма будет `O(m * g(H))`

2.  Наивный алгоритм каждый раз сдвигает шаблон относительно текста на один символ, и заново посимвольно проверяет есть ли совпадения. В среднем отрабатывает за `2H`, в худшем случае (когда очень длинная строка например `aaa.....ab`, а шаблон `aaaaaac`) время будет `O(Hn)`
    Таким образом для моего алгоритма в худщем случае time complexity будет `O(m * H * n)`
    Расход памяти, если не принимать в расчет список улиц, который уже находится в памяти - `H + n`

3.  Алгоритм Бойера-Мура-Хорспула - тратит незначительное время на подготовку для искомого шаблона за `O(n + E)`, что позволяет ему сдвигать шаблон относительно начала текста в зависимости от ситуации более чем на один символ, далее отрабатывает в среднем за время `2H / E`, в худшем за `O(H * n)`
    Таким образом для моего алгоритма в худщем случае time complexity будет `O(m * H * n)`  
    Расход памяти, если не принимать в расчет список улиц, который уже находится в памяти - `H + n + E`

Все перечисленные подходы решают поставленную задачу вывода suggest'ов для всех улиц Москвы за более чем приемлемое время (учитывая, что время между нажатиями на клавиши не привышает 150мс, а все алгоритмы отрабатывают быстрее чем за несколько мс). Таким образом стоит сделать выбор в пользу наиболее читаемого варианта. Таковым является indexOf

Для серьезных объемов (миллионы строк например, либо много достаточно длинных строк), и условие, что у нас достаточно памяти, я бы использовал суффиксные деревья. Надеюсь до проверки успею запилить быстрое построение деревьев по алгоритму Укконена для миллиона строк + мгновенный поиск.
